% !TeX spellcheck = ru_RU
% !TEX root = vkr.tex

\section{Обзор}
\label{sec:relatedworks}
\subsection{Mybuild}
\subsubsection{Обзор}
Embox является модульной и настраиваемой ОСРВ. Для описания таких модулей и конфигураций используется система сборки Mybuild, которая генерирует make-файлы и остальные необходимые для создания образа файлы. Система полностью написана на языке GNU Make и состоит из следующих частей:
\begin{itemize}
	% \item классические make-файлы, где реализована логика описания модулей, с помощью двух декларативных языков - Myfile и Configfile. Синтаксис данных языков вдохновлялся Java;
	\item классические make-файлы, к которым в основном относятся \\ скрипты раскрутки;
	      % \item синтаксическое расширение языка GNU Make, которое позволяет определять функции и классы;
	\item библиотеки функций, т.е. make-файлы, написанные на синтаксическом расширении языка GNU Make, где находится большая часть логики системы сборки;
	\item вспомогательные скрипты, которые могут порождать \\ дополнительные файлы в образе сборки.
\end{itemize}

\subsubsection{Процесс сборки}
% (Здесь можно вставить код из mk/build.mk либо сделать диаграмму последовательности вызовов)
Процесс создания образа ОС с помощью Mybuild можно разбить на следующие стадии:
\begin{enumerate}
	\item подготовка скриптов;
	\item создание графа описания модулей;
	\item создание модели системы;
	\item генерация необходимых ресурсов;
	\item запуск скриптов на исполнение.
\end{enumerate}

\subsubsection{Подготовка скриптов}
Так как скрипты написаны на синтаксическом расширении языка GNU Make, необходимо преобразовать их с помощью препроцессора. Затем, чтобы избежать повторного запуска препроцессора на всех скриптах после небольших изменений, используется скрипт кэширования \\(mk/script/mk-cache.mk)
\begin{lstlisting}[caption=Пример определения класса, language=Java, frame=single, breaklines, mathescape]
    define class-Foo
        $\mbox{\$}$(field message,$\mbox{\$}$1)
        $\mbox{\$}$(method sayHello,
            $\mbox{\$}$(info $\mbox{\$}$(get-field message)))
    endef
    define some_func
        $\mbox{\$}$(for foo <- $\mbox{\$}$(new Foo,Privet!),
            $\mbox{\$}$(invoke foo->sayHello)
            $\mbox{\#}$ Return the instance.
            $\mbox{\$}$(foo))
    endef
\end{lstlisting}
% В Mybuild реализованы два декларативных языка программирования: Myfile - для описания модулей ОС, Configfile - для описания конфигураций ОС. Они имеют довольно схожий синтаксис, который вдохновлен Java. Также эти языки поддерживают ООП (а именно классы и наследование).

% Для создания парсера используется генератор LALR-парсеров GOLD Parsing System \footnote{\href{http://www.goldparser.org/}{http://www.goldparser.org/}}, написанный на GNU Make. Следует отметить, что последняя версия данной утилиты (GOLD 5.2.0), была выпущена в 18 августа 2012 года, что говорит о том, что она deprecated.
\subsubsection{Языки описания}
Mybuild позволяет описывать проект с помощью двух декларативных объектно-ориентированных языков программирования:
\begin{itemize}
	\item Myfile --- для описания модулей;
	\item Configfile --- для описания конфигураций.
\end{itemize}
Данные языки имеют схожий синтаксис, который вдохновлен Java.

Для синтаксического разбора декларативных языков используется генератор LALR-парсеров \cite{10.5555/1951778} GOLD Parsing system \footnote{\href{http://www.goldparser.org/}{http://www.goldparser.org/}}, который также, как и Mybuild, написан на GNU Make. Грамматика для языка в данной утилите описывается с помощью своего диалекта EBNF (Extended Backus-Naur Form) \footnote {\href{http://www.goldparser.org/doc/grammars/index.htm}{http://www.goldparser.org/doc/grammars/index.htm}}. Следует отметить, что последняя версия генератора \\ (GOLD 5.2.0) была выпущена 18-го августа 2012 года, что означает, что данный инструмент является устаревшим и больше не поддерживается.

\subsubsection{Создание графа описания модулей}
Можно получить граф описания модулей в результате следующей последовательности действий:
\begin{enumerate}
	\item поиск всех .my-файлов и Myfile'ов в директории с исходным кодом;
	\item синтаксический разбор с помощью GOLD, и на основе разбора построение модели файла (mk/mybuild/myfile-model.mk);
	\item объединение всех моделей в граф;
	\item проведение необходимых проверок (на ацикличность и т.д.);
	\item кэширование полученного набора моделей.
\end{enumerate}

\subsubsection{Создание модели системы}
Далее происходит синтаксический разбор конфигурационных файлов, где в каждом из них описаны необходимые для конкретной сборки модули.
% Также как и для
\subsubsection{Генерация необходимых ресурсов}
\subsubsection{Скрипты создания образа}
\subsubsection{Пример описания простейшего модуля}
Чтобы продемонстрировать работу Mybuild, в официальной документации
\footnote{\href{https://github.com/embox/embox-docs/releases/download/latest/embox\_quick\_start\_ru.pdf}
	{https://github.com/embox/embox-docs/releases/download/latest/embox\_quick\_start\_ru.pdf}} есть следующий пример добавления модуля в образ ОС:

\begin{lstlisting}[caption=Пример описания модуля, language=Java, frame=single, breaklines]
package embox.cmd
@AutoCmd
@Cmd(name = "hello", help="First Embox application")
module hello {
    source "hello.c"
}
\end{lstlisting}

\begin{lstlisting}[caption=Пример описания конфигурации, language=Java, frame=single, breaklines]
package genconfig
configuration conf {
    // ...
    include embox.cmd.tutorial.hello
}
\end{lstlisting}

Создав директорию ./src/cmds/hello, добавив в нее hello.c и файл Mybuild c описанием модуля (Листинг 1), и добавив данный модуль в необходимую конфигурацию (Листинг 2), можно собрать образ системы (например, для x86-qemu) и запустить тестовый модуль с помощью:
\begin{lstlisting}[caption=Запуск тестового модуля, language=bash, frame=single, breaklines]
    make confload-x86/qemu
    make
    ./scripts/qemu/auto_qemu
\end{lstlisting}
\subsection{Инструменты}
\subsubsection[short]{Menhir и ocamllex}
В качестве инструментов для построения парсера были выбраны генератор лексических анализаторов ocamllex и генератор синтаксических анализаторов Menhir. Menhir является генератором LR(1) парсеров \cite{2021MenhirRM}, что означает, что такой парсер способен распознавать LALR(1)-языки. Следовательно такой генератор парсеров подходит для задачи.

Также был рассмотрен вариант использования библиотеки парсер-комбинаторов, например Angstrom \footnote{\href{https://github.com/inhabitedtype/angstrom}{https://github.com/inhabitedtype/angstrom}}. Хоть парсеры-комбинаторы и считаются более выразительным инструментом для синтаксического анализа, для данной данной задачи разбора декларативного LALR(1)-язы\-ка по уже существующей грамматике будет удобнее использовать генератор парсеров.
% ссылку бы добавить.....

% \emph{Обзор должен быть.} Здесь нужно писать, что индустрия и наука уже сделали по вашей теме. Он нужен, чтобы Вы случайно не изобрели какой-нибудь велосипед.

% По-английски называется related works или previous works.

% Если Ваша работа является развитием предыдущей и плохо понима\-ема без неё, то обзор должен идти в начале. Если же Вы решаете некоторую задачу новым интересным способом, то если поставить обзор в начале, то читатель может устать, пока доберется до вашего решения. В этом случае уместней поставить обзор после описания Вашего подхода к проблеме\footnote{Такой подход рекомендуется в работе~\cite{SPJGreatPaper}.
% 	Вполне возможно, что Ваш реальный научный руководитель будет не согласен, и потребует, чтобы обзор был в начале.}.

% В обзоре вам нужно рассказать про \emph{преимущества и недостатки} того, что было сделано до Вас.
% Неправильным будет перечислять только недостатки, так как если Ваша работа хоть где-то хуже предыдущей, то рецензент будет радостно потирать руки и заваливать Вашу работу.
% Гораздо лучше, если Вы честно признаетесь в этом сами.

% В обзоре необходимо ссылаться на работы других людей. В данном шаблоне задумано, что литература будет указываться в файле \verb=vkr.bib=. В нём указываются пункты литературы в формате \BibTeX{}, а затем на них можно ссылаться с помощью \verb=\cite{...}=. Та литература, на которую Вы сошлетесь, попадет в список литературы в конце документа. Если не сошлетесь~---  не попадёт. Спецификацию в формате \BibTeX{} почти никогда (для второго курса~--- никогда), не нужно придумывать руками. Правильно: находить в интернете описание цитируемой статьи\footnote{Например, \url{https://dl.acm.org/doi/10.1145/3408995} (дата доступа:   \DTMdate{2022-12-17}).},
% копировать цитату с помощью кнопки \foreignquote{english}{Export Citation} и вставлять в \BibTeX{} файл.
% Если так не делать, то оформление литературы будет обрастать ошибками.
% Например, \BibTeX{} по особенному обрабатывает точ\-ки, запятые и \verb=and= в списке авторов, что позволяет ему самому понимать, сколько авторов у статьи, и что там фамилия, что~--- имя, а что~--- отчество.

% В обзоре и в остальном тексте вы наверняка будете использовать названия продуктов или языков программирования.
% Для них рекоменду\-ется (в файле \verb=preamble2.tex=) за\-дать специальные команды, чтобы писать сложные названия правильно и одинаково по всему доку\-менту.
% Написать с ошибкой  название любимого языка программирова\-ния науч\-ного руко\-водителя~--- идеальный вариант его разозлить.
